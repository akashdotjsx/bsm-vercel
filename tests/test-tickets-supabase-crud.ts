/**
 * Tickets Supabase Direct CRUD Test Script
 * 
 * Tests all CRUD operations for tickets using Supabase client directly
 * This bypasses GraphQL to verify database access and RLS policies
 * Run with: npx tsx tests/test-tickets-supabase-crud.ts
 */

import { config } from 'dotenv'
import { createClient } from '@supabase/supabase-js'

// Load environment variables
config({ path: '.env.local' })

// Color codes
const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
  magenta: '\x1b[35m',
}

const log = {
  success: (msg: string) => console.log(`${colors.green}‚úì${colors.reset} ${msg}`),
  error: (msg: string) => console.log(`${colors.red}‚úó${colors.reset} ${msg}`),
  info: (msg: string) => console.log(`${colors.blue}‚Ñπ${colors.reset} ${msg}`),
  test: (msg: string) => console.log(`${colors.cyan}‚Üí${colors.reset} ${msg}`),
  section: (msg: string) => console.log(`\n${colors.yellow}${'‚îÅ'.repeat(70)}\n  ${msg}\n${'‚îÅ'.repeat(70)}${colors.reset}`),
  title: (msg: string) => console.log(`\n${colors.magenta}${'‚ïê'.repeat(70)}\n  ${msg}\n${'‚ïê'.repeat(70)}${colors.reset}\n`),
}

let testOrganizationId: string
let testRequesterId: string
let testAssigneeId: string
let createdTicketId: string
let supabase: ReturnType<typeof createClient>

function initSupabase() {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
  const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY!
  
  if (!supabaseUrl || !supabaseKey) {
    throw new Error('Missing Supabase credentials')
  }
  
  supabase = createClient(supabaseUrl, supabaseKey, {
    auth: { persistSession: false }
  })
  
  log.success('Supabase client initialized')
}

async function setupTestData() {
  log.section('üîß SETUP: Preparing test data')
  
  // Get first organization
  log.test('Fetching organization...')
  const { data: orgData, error: orgError } = await supabase
    .from('organizations')
    .select('id, name')
    .limit(1)
    .single()
  
  if (orgError || !orgData) {
    log.error(`Failed to fetch organization: ${orgError?.message}`)
    process.exit(1)
  }
  
  testOrganizationId = orgData.id
  log.success(`Organization found: ${testOrganizationId} (${orgData.name})`)
  
  // Get active users
  log.test('Fetching user profiles...')
  const { data: profilesData, error: profilesError } = await supabase
    .from('profiles')
    .select('id, display_name, email')
    .eq('is_active', true)
    .limit(2)
  
  if (profilesError || !profilesData || profilesData.length === 0) {
    log.error(`Failed to fetch profiles: ${profilesError?.message}`)
    process.exit(1)
  }
  
  if (profilesData.length >= 2) {
    testRequesterId = profilesData[0].id
    testAssigneeId = profilesData[1].id
    log.success(`Requester: ${profilesData[0].display_name} (${profilesData[0].email})`)
    log.success(`Assignee: ${profilesData[1].display_name} (${profilesData[1].email})`)
  } else {
    testRequesterId = profilesData[0].id
    testAssigneeId = testRequesterId
    log.info('Only one user found - using same for requester and assignee')
  }
  
  log.success('‚úÖ Test data setup complete\n')
}

async function testCreateTicket() {
  log.section('üìù TEST 1: CREATE - Create New Ticket')
  
  const ticketData = {
    organization_id: testOrganizationId,
    requester_id: testRequesterId,
    assignee_id: testAssigneeId,
    // ticket_number will be auto-generated by database trigger
    title: `Supabase CRUD Test Ticket - ${new Date().toISOString()}`,
    description: 'This is a test ticket created via Supabase client to verify CRUD operations',
    type: 'incident',
    priority: 'high',
    status: 'new',
    urgency: 'high',
    impact: 'medium',
    tags: ['test', 'supabase', 'crud'],
    custom_fields: { test: true, automated: true }
  }
  
  try {
    log.test('Creating ticket...')
    const { data, error } = await supabase
      .from('tickets')
      .insert(ticketData)
      .select()
      .single()
    
    if (error) {
      log.error(`‚ùå CREATE failed: ${error.message}`)
      log.error(`Error details: ${JSON.stringify(error, null, 2)}`)
      return false
    }
    
    if (!data) {
      log.error('‚ùå No data returned from insert')
      return false
    }
    
    createdTicketId = data.id
    
    log.success(`‚úÖ Ticket created successfully!`)
    log.info(`   ID: ${data.id}`)
    log.info(`   Number: ${data.ticket_number}`)
    log.info(`   Title: ${data.title}`)
    log.info(`   Type: ${data.type}`)
    log.info(`   Priority: ${data.priority}`)
    log.info(`   Status: ${data.status}`)
    
    return true
  } catch (error) {
    log.error(`‚ùå CREATE failed: ${error}`)
    console.error(error)
    return false
  }
}

async function testReadTicket() {
  log.section('üìñ TEST 2: READ - Fetch Ticket by ID')
  
  try {
    log.test(`Fetching ticket ${createdTicketId}...`)
    const { data, error } = await supabase
      .from('tickets')
      .select('*')
      .eq('id', createdTicketId)
      .single()
    
    if (error) {
      log.error(`‚ùå READ failed: ${error.message}`)
      return false
    }
    
    if (!data) {
      log.error('‚ùå Ticket not found!')
      return false
    }
    
    log.success(`‚úÖ Ticket fetched successfully!`)
    log.info(`   Title: ${data.title}`)
    log.info(`   Description: ${data.description}`)
    log.info(`   Type: ${data.type}`)
    log.info(`   Priority: ${data.priority}`)
    log.info(`   Status: ${data.status}`)
    log.info(`   Tags: ${data.tags?.join(', ') || 'N/A'}`)
    log.info(`   Custom Fields: ${JSON.stringify(data.custom_fields)}`)
    
    return true
  } catch (error) {
    log.error(`‚ùå READ failed: ${error}`)
    console.error(error)
    return false
  }
}

async function testReadTicketWithRelations() {
  log.section('üìñ TEST 3: READ - Fetch Ticket with Relations (Requester & Assignee)')
  
  try {
    log.test('Fetching ticket with relations...')
    const { data, error } = await supabase
      .from('tickets')
      .select(`
        *,
        requester:profiles!requester_id(id, display_name, email),
        assignee:profiles!assignee_id(id, display_name, email)
      `)
      .eq('id', createdTicketId)
      .single()
    
    if (error) {
      log.error(`‚ùå READ with relations failed: ${error.message}`)
      return false
    }
    
    if (!data) {
      log.error('‚ùå Ticket not found!')
      return false
    }
    
    log.success(`‚úÖ Ticket with relations fetched successfully!`)
    log.info(`   Requester: ${data.requester?.display_name} (${data.requester?.email})`)
    log.info(`   Assignee: ${data.assignee?.display_name} (${data.assignee?.email})`)
    
    return true
  } catch (error) {
    log.error(`‚ùå READ with relations failed: ${error}`)
    console.error(error)
    return false
  }
}

async function testUpdateTicket() {
  log.section('‚úèÔ∏è  TEST 4: UPDATE - Update Ticket Fields')
  
  const updates = {
    title: 'UPDATED: Supabase CRUD Test Ticket',
    description: 'This ticket has been updated via Supabase client',
    priority: 'urgent',
    status: 'in_progress',
    type: 'problem'
  }
  
  try {
    log.test('Updating ticket fields...')
    const { data, error } = await supabase
      .from('tickets')
      .update(updates)
      .eq('id', createdTicketId)
      .select()
      .single()
    
    if (error) {
      log.error(`‚ùå UPDATE failed: ${error.message}`)
      return false
    }
    
    if (!data) {
      log.error('‚ùå No data returned from update')
      return false
    }
    
    log.success(`‚úÖ Ticket updated successfully!`)
    log.info(`   New Title: ${data.title}`)
    log.info(`   New Description: ${data.description}`)
    log.info(`   New Priority: ${data.priority}`)
    log.info(`   New Status: ${data.status}`)
    log.info(`   New Type: ${data.type}`)
    log.info(`   Updated At: ${data.updated_at}`)
    
    return true
  } catch (error) {
    log.error(`‚ùå UPDATE failed: ${error}`)
    console.error(error)
    return false
  }
}

async function testListTickets() {
  log.section('üìã TEST 5: LIST - Fetch All Tickets with Pagination')
  
  try {
    log.test('Fetching tickets list (first 10)...')
    const { data, error } = await supabase
      .from('tickets')
      .select('id, ticket_number, title, type, priority, status, created_at')
      .order('created_at', { ascending: false })
      .limit(10)
    
    if (error) {
      log.error(`‚ùå LIST failed: ${error.message}`)
      return false
    }
    
    const tickets = data || []
    log.success(`‚úÖ Fetched ${tickets.length} tickets`)
    
    tickets.slice(0, 5).forEach((ticket: any, index: number) => {
      log.info(`   ${index + 1}. [${ticket.ticket_number}] ${ticket.title} (${ticket.status})`)
    })
    
    if (tickets.length > 5) {
      log.info(`   ... and ${tickets.length - 5} more`)
    }
    
    return true
  } catch (error) {
    log.error(`‚ùå LIST failed: ${error}`)
    console.error(error)
    return false
  }
}

async function testFilterTickets() {
  log.section('üîç TEST 6: FILTER - Query Tickets by Status and Priority')
  
  try {
    log.test('Filtering tickets by status (in_progress)...')
    const { data: statusData, error: statusError } = await supabase
      .from('tickets')
      .select('id, ticket_number, title, priority, status')
      .eq('status', 'in_progress')
      .limit(10)
    
    if (statusError) {
      log.error(`‚ùå FILTER by status failed: ${statusError.message}`)
      return false
    }
    
    log.success(`‚úÖ Filter by status='in_progress': Found ${statusData?.length || 0} tickets`)
    
    log.test('Filtering tickets by priority (high or urgent)...')
    const { data: priorityData, error: priorityError } = await supabase
      .from('tickets')
      .select('id, ticket_number, title, priority, status')
      .in('priority', ['high', 'urgent'])
      .limit(10)
    
    if (priorityError) {
      log.error(`‚ùå FILTER by priority failed: ${priorityError.message}`)
      return false
    }
    
    log.success(`‚úÖ Filter by priority IN ['high','urgent']: Found ${priorityData?.length || 0} tickets`)
    
    log.test('Filtering tickets by type (incident)...')
    const { data: typeData, error: typeError } = await supabase
      .from('tickets')
      .select('id, ticket_number, title, priority, status')
      .eq('type', 'incident')
      .limit(10)
    
    if (typeError) {
      log.error(`‚ùå FILTER by type failed: ${typeError.message}`)
      return false
    }
    
    log.success(`‚úÖ Filter by type='incident': Found ${typeData?.length || 0} tickets`)
    
    return true
  } catch (error) {
    log.error(`‚ùå FILTER failed: ${error}`)
    console.error(error)
    return false
  }
}

async function testDeleteTicket() {
  log.section('üóëÔ∏è  TEST 7: DELETE - Remove Ticket')
  
  try {
    log.test(`Deleting ticket ${createdTicketId}...`)
    const { error } = await supabase
      .from('tickets')
      .delete()
      .eq('id', createdTicketId)
    
    if (error) {
      log.error(`‚ùå DELETE failed: ${error.message}`)
      return false
    }
    
    log.success(`‚úÖ Ticket deleted successfully!`)
    
    // Verify deletion
    log.test('Verifying deletion...')
    const { data, error: verifyError } = await supabase
      .from('tickets')
      .select('id')
      .eq('id', createdTicketId)
      .single()
    
    if (verifyError && verifyError.code === 'PGRST116') {
      // PGRST116 = No rows returned
      log.success('‚úÖ Deletion verified - ticket no longer exists')
      return true
    } else if (data) {
      log.error('‚ùå Deletion failed - ticket still exists')
      return false
    }
    
    return true
  } catch (error) {
    log.error(`‚ùå DELETE failed: ${error}`)
    console.error(error)
    return false
  }
}

async function main() {
  log.title('üéØ TICKETS SUPABASE CRUD - Comprehensive Test Suite')
  
  const results: Record<string, boolean> = {}
  
  try {
    // Initialize
    initSupabase()
    
    // Setup
    await setupTestData()
    
    // Run all tests
    results['CREATE'] = await testCreateTicket()
    results['READ'] = await testReadTicket()
    results['READ_WITH_RELATIONS'] = await testReadTicketWithRelations()
    results['UPDATE'] = await testUpdateTicket()
    results['LIST'] = await testListTickets()
    results['FILTER'] = await testFilterTickets()
    results['DELETE'] = await testDeleteTicket()
    
    // Summary
    log.title('üìä FINAL TEST RESULTS')
    
    const passed = Object.values(results).filter(r => r).length
    const total = Object.keys(results).length
    
    console.log('')
    Object.entries(results).forEach(([test, success]) => {
      const status = success 
        ? `${colors.green}‚úì PASS${colors.reset}` 
        : `${colors.red}‚úó FAIL${colors.reset}`
      const label = test.padEnd(25)
      console.log(`  ${label} ${status}`)
    })
    
    console.log(`\n${'‚ïê'.repeat(70)}`)
    const percentage = Math.round((passed / total) * 100)
    console.log(`  ${passed}/${total} tests passed (${percentage}%)`)
    console.log(`${'‚ïê'.repeat(70)}\n`)
    
    if (passed === total) {
      console.log(`${colors.green}üéâ All tests passed! Tickets CRUD is working perfectly!${colors.reset}\n`)
      process.exit(0)
    } else {
      console.log(`${colors.red}‚ùå ${total - passed} test(s) failed${colors.reset}\n`)
      process.exit(1)
    }
    
  } catch (error) {
    log.error(`\n‚ùå Test suite crashed: ${error}`)
    console.error(error)
    process.exit(1)
  }
}

// Run tests
main()
